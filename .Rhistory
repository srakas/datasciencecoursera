res <- makeCacheMatrix(d)
res
res$get()
res$getInverseMat()
res$setInverseMat()
res$getInverseMat()
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverseMat <- x$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- x$setInverseMat()
inverseMat
}
cacheSolve(d)
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
res <- makeCacheMatrix(d)
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
cacheSolve(d)
cacheSolve(d)
message("Getting cached data")
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
inverseMat
}
cacheSolve(d)
cacheSolve(d)
cacheSolve(d)
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
inverseMat <- res$setInverseMat()
inverseMat
}
cacheSolve(d)
cacheSolve(d)
cacheSolve(d)
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
message("Test it")
## Return a matrix that is the inverse of 'x'
res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
cacheSolve(d)
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
res <<- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
cacheSolve(d)
cacheSolve(d)
cacheSolve(d)
cacheSolve(d)
cacheSolve(d)
## Put comments here that give an overall description of what your
## functions do
## Compare two matrices and returns false if they are not of the same dimesions
## or if they don't have same values; otherwise returns true
matEqual <- function(x, y) {
is.matrix(x) && is.matrix(y) && dim(x) == dim(y) && all(x == y)
}
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
#res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
res <- makeCacheMatrix(d)
res$get()
res$getINverseMat()
res$getInverseMat()
res$setInverseMat()
res$getInverseMat()
res$getInverseMat()
res$getInverseMat()
res$getInverseMat()
cacheSolve(res)
cacheSolve(res)
res$set(d)
cacheSolve(res)
cacheSolve(res)
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
cacheSolve(res)
res$set(d)
cacheSolve(res)
cacheSolve(res)
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
#message("Getting cached data")
## Caching the inverse of the matrix
## Creates matrix cache from the matrix 'x'
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Return a matrix that is the inverse of 'x'
## If the matrix did not change and inverse has already been calculated
## the inverse is pulled from the cache, otherwise calculates matrix inverse
cacheSolve <- function(x, ...) {
#res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
#message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
cacheSolve(res)
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
## Caching the inverse of the matrix
## Creates matrix cache from the matrix 'x'
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Return a matrix that is the inverse of 'x'
## If the matrix did not change and inverse has already been calculated
## the inverse is pulled from the cache, otherwise calculates matrix inverse
cacheSolve <- function(x, ...) {
#res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
my_matrix <- makeCacheMatrix(matrix(rnorm(16),4,4))
cacheSolve(my_matrix)
my_matrix$get() %*% cacheSolve(my_matrix)
my_matrix$get() %*% cacheSolve(my_matrix)
my_matrix$get()
my_matrix$get() * cacheSolve(my_matrix)
cacheSolve(my_matrix)
my_matrix <- makeCacheMatrix(matrix(rnorm(16),4,4))
cacheSolve(my_matrix)
my_matrix
my_matrix$get()
matrix(rnorm(16),4,4)
matrix(rnorm(16),4,4)
matrix(rnorm(16),4,4)
set.seed(77)
m <- matrix(sample.int(100,size=9,replace=TRUE), nrow=3)
m
res <- makeCacheMatrix(m)
cacheSolve(d)
set.seed(77)
m <- matrix(sample.int(100,size=16,replace=TRUE), nrow=4)
m
d <- makeCacheMatrix(m)
cacheSolve(d)
## Caching the inverse of the matrix
## Creates matrix cache from the matrix 'x'
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Return a matrix that is the inverse of 'x'
## If the matrix did not change and inverse has already been calculated
## the inverse is pulled from the cache, otherwise calculates matrix inverse
cacheSolve <- function(x, ...) {
#res <- makeCacheMatrix(x)
inverseMat <- res$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- res$setInverseMat()
inverseMat
}
set.seed(77)
m <- matrix(sample.int(100,size=9,replace=TRUE), nrow=3)
m
d <- makeCacheMatrix(m)
cacheSolve(d)
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
## Caching the inverse of the matrix
## Creates matrix cache from the matrix 'x'
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Return a matrix that is the inverse of 'x'
## If the matrix did not change and inverse has already been calculated
## the inverse is pulled from the cache, otherwise calculates matrix inverse
cacheSolve <- function(x, ...) {
#res <- makeCacheMatrix(x)
inverseMat <- x$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- x$setInverseMat()
inverseMat
}
m <- matrix(sample.int(100,size=9,replace=TRUE), nrow=3)
m
## Caching the inverse of the matrix
## Creates matrix cache from the matrix 'x'
makeCacheMatrix <- function(x = matrix()) {
inverseMat <- NULL
set <- function(y) {
x <<- y
inverseMat <<- NULL
}
get <- function() x
setInverseMat <- function() {
inverseMat <<- solve(x)
}
getInverseMat <- function() inverseMat
list(set = set, get = get, setInverseMat = setInverseMat, getInverseMat = getInverseMat)
}
## Return a matrix that is the inverse of 'x'
## If the matrix did not change and inverse has already been calculated
## the inverse is pulled from the cache, otherwise calculates matrix inverse
cacheSolve <- function(x, ...) {
#res <- makeCacheMatrix(x)
inverseMat <- x$getInverseMat()
if (!is.null(inverseMat)) {
message("Getting cached data")
return(inverseMat)
}
inverseMat <- x$setInverseMat()
inverseMat
}
set.seed(77)
m <- matrix(sample.int(100,size=9,replace=TRUE), nrow=3)
m
d <- makeCacheMatrix(m)
cacheSolve(d)
set.seed(77)
m <- matrix(sample.int(100,size=16,replace=TRUE), nrow=4)
d <- makeCacheMatrix(m)
cacheSolve(d)
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
my_matrix <- makeCacheMatrix(matrix(rnorm(16),4,4))
my_matrix$get() %*% cacheSolve(my_matrix)
d$get() %*% cacheSolve(d)
d
d$get()
m <- matrix(sample.int(100,size=9,replace=TRUE), nrow=3)
m
d <- makeCacheMatrix(m)
d$get() %*% cacheSolve(d)
set.seed(77)
m <- matrix(sample.int(100,size=9,replace=TRUE), nrow=3)
m
inversa <- makeCacheMatrix(m)
cacheSolve(inversa)
inversa$set(m)
cacheSolve(inversa)
cacheSolve(inversa)
set.seed(77)
m <- matrix(sample.int(100,size=25,replace=TRUE), nrow=5)
x <- makeCacheMatrix(m)
x$get() %*% cacheSolve(x)
cacheSolve(x)
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
source('~/datascience/coursera/ProgrammingAssignment2/cachematrix.R')
